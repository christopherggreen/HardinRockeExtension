\documentclass[11pt]{article}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}

%\VignetteIndexEntry{Extending Hardin and Rocke (2005)---Simulation}
%\VignetteDepends{HardinRockeExtension}
\SweaveOpts{prefix.string=hr, eps=FALSE, pdf=TRUE, strip.white=true}
\SweaveOpts{width=6, height=4.1}

%\usepackage{amsmath}
%\usepackage{amsfonts}% \mathbb
%\usepackage{mathtools}% -> \floor, \ceil
\usepackage[utf8]{inputenc}
%% The following is partly R's share/texmf/Rd.sty
\usepackage{color}
\usepackage{hyperref}
\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{Red}{rgb}{0.7,0,0}
\hypersetup{%
  hyperindex,%
  colorlinks={true},%
  pagebackref,%
  linktocpage,%
  plainpages={false},%
  linkcolor={Blue},%
  citecolor={Blue},%
  urlcolor={Red},%
  pdfstartview={XYZ null null 1},%
  pdfview={XYZ null null null},%
}

\usepackage{natbib}
\usepackage[noae]{Sweave}
%----------------------------------------------------
%\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
%\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
%\DeclareMathOperator{\sign}{sign}
%\newcommand{\abs}[1]{\left| #1 \right|}
%\newtheorem{definition}{Definition}
%\newcommand{\byDef}{\mathrm{by\ default}}
%\newcommand{\R}{{\normalfont\textsf{R}}{}}
%\newcommand{\texttt}[1]{\texttt{#1}}
%\newcommand*{\pkg}[1]{\texttt{#1}}
%\newcommand*{\CRANpkg}[1]{\href{http://CRAN.R-project.org/package=#1}{\pkg{#1}}}

%----------------------------------------------------
\begin{document}
%\setkeys{Gin}{width=0.9\textwidth}
%\setlength{\abovecaptionskip}{-5pt}

\title{Extending Hardin and Rocke (2005)---Simulation Work}
\author{Christopher~G. Green}
\maketitle
%\tableofcontents
<<init, echo=FALSE>>=
@

\section{Introduction}
This vignette shows how to use the function
\texttt{hr.cm} to replicate and extend the 
Monte Carlo simulation performed in 
\cite{HardinRocke:2005} to calculate the 
Wishart degrees of freedom m associated
with the Hardin-Rocke approximation to 
the MCD covariance estimate. \cite{HardinRocke:2005}
calculated this for the maximum breakdown
point case of the MCD, and \cite{GreenMartin:2014}
extended this to the MCD using an arbitrary
fraction of the data.

We assume the reader can set up a cluster
using the \texttt{parallel} package, but this
is not necessary: one can create a cluster with
a single node.

Note that all code blocks in the vignette are marked
as ``do not evaluate'' to avoid running long simulations
during package checks. In the \texttt{R} code file 
resulting from running \texttt{Stangle} on the vignette
source, you will need to uncomment all the \texttt{R}
code to actually run the simulation.

\section{Setup}
First, we load some required packages and take care of some performance
tuning. The simulation requires the \texttt{CerioliOutlierDetection}
package as well as the \texttt{parallel} package. We also load the
\texttt{RhpcBLASctl} package to force the use of single-threaded BLAS,
if possible: with a multi-threaded BLAS on a multi-core machine, the
cluster ``nodes'' may impede each other. We want each worker to have
the node to itself for maximum efficiency.
<<setup, eval=FALSE>>=
# Christopher G. Green
# 2014-02-24
#
# run simulations in parallel

require( RhpcBLASctl             )
require( parallel                )
require( CerioliOutlierDetection )
require( HardinRockeExtension    )

# force single-threaded BLAS if possible
omp_set_num_threads(1)
@

Create a cluster using one of the \texttt{makeXXcluster}
functions from the \texttt{parallel} package. On Windows,
\texttt{makePSOCKcluster} is the only available option.
We assume 10 nodes here. \texttt{hrSimParallel} will 
distribute the work within a simulation run across 
the cluster.

The \texttt{useXDR} option should be set to FALSE
on little endian machines for efficiency.
<<makecluster, eval=FALSE>>=
thecluster <- makePSOCKcluster(10, 
	outfile="hrsim_replicate.log", useXDR=FALSE)
@

We initialize the cluster random number generator
with a seed; this makes it possible for you to 
replicate our numbers and the resulting figures.
<<reproduce, eval=FALSE>>=
# make reproducible
clusterSetRNGStream(cl = thecluster, 2014)
@

Now we initialize each cluster node using
\texttt{clusterEvalQ}. Each node needs a copy
of the two libraries we use for the simulation,
and we create a logfile for each node, tagged
with the process ID of the worker process running
on the node.

Hardin and Rocke used 5000 simulation runs. We set 
a block size of 250 to manage the memory use on our
machine; this will allocate 250 runs to each cluster
node.
<<clusterinit, eval=FALSE>>=
# initialize each node
tmp.rv <- clusterEvalQ( cl = thecluster, {
  require( CerioliOutlierDetection )
  require( HardinRockeExtension    )
  require( mvtnorm                 )

  N.SIM <- 5000
  B.SIM <- 500

  my.pid <- Sys.getpid()
  cat("My pid is ", my.pid, "\n")
  logfile <- paste("Simulation_AllAlphas_Parallel_logfile_",
    my.pid,".txt",sep="")
  cat("Initialized\n\n", file=logfile)

  invisible(NULL)
})
@

Next, we generate the cases we will want to run. Each case
consists of a dimension $p$, a sample size $n$, and an MCD
fraction $\alpha$. Hardin and Rocke used $p \in \{5, 10, 20\}$
and $n \in \{50,100,500,1000\}$, and assumed $\alpha$ was
equal to the maximum breakdown point fraction 
$\frac{\lfloor (n+p+1)/2 \rfloor}{n}$. We run some additional
dimensions, sample sizes, and MCD fractions here in order to 
expand their model.

We chose to order the cases by decreasing sample size so that
the most ``expensive'' cases would run first on our cluster; this
is not required.

Finally, we rotate the matrix of cases to a data frame for use
with lapply and variants (recall that a data frame is a list of
its columns).
<<buildcases, eval=FALSE>>=
# build the pairs of sample size n and dimension p
hr.cm.params <- expand.grid(
  list(
    p=c(3,5,7,10,15,20),
    n=c(50,100,250,500,750,1000)
  )
)
# adding more coverage for small sample sizes
hr.cm.params <- rbind( hr.cm.params, within( 
  expand.grid(list(p=c(3,5,7,10,15,20), 
    ratio=c( 3,5,7,9,11 ) )), 
  {
    n <- p * ratio
    rm(ratio)
  }
))
# remove any duplicates
hr.cm.params <- unique(hr.cm.params)
# want to run most expensive cases first
hr.cm.params <- hr.cm.params[ order( hr.cm.params$n, 
  hr.cm.params$p, decreasing=TRUE ), ]

# add maximum breakdown point case to the params data set
hr.cm.params[,"mbp"] <- apply( hr.cm.params, 1, 
  function(x) floor( (x[2] + x[1] + 1)/2 )/x[2] )

# want each case to be a column so that we can use parLapply
hr.cm.params <- data.frame(t(as.matrix(hr.cm.params)))
      
mcd.alphas <- c(0.55,0.60,0.65,0.70,0.75,0.80,
  0.85,0.90,0.95,0.99,0.995) 
clusterExport(cl = thecluster, "hr.cm.params")
clusterExport(cl = thecluster, "mcd.alphas")
@

\section{Simulation Runs}
Now we run the simulation. We distribute the work of each
case across the cluster. 

Remember to stop your cluster when you're done.
<<runsim, eval=FALSE>>=
cat("Starting run at ", format(Sys.time()), "\n")

#
# using parLapply here to prevent simplification of the
# results (as parApply would attempt to do)
#
hr.cm.results.all.pre <- parLapply(cl = thecluster, 
  X = hr.cm.params, 
  function(pn) {
    cat("Starting case p = ",pn[1]," n = ",pn[2]," at time ", 
      format(Sys.time()), " \n",file=logfile,append=TRUE)
    results <- hr.cm(p = pn[1] , n = pn[2], N=N.SIM, B=B.SIM, 
      mcd.alpha=unique(c(pn[3],mcd.alphas)), logfile=logfile)
    cat("Finished case p = ",pn[1]," n = ",pn[2]," at time ", 
      format(Sys.time()), " \n",file=logfile,append=TRUE)
    data.frame(p=pn[1],n=pn[2],mbp=pn[3],results)
  }
)
cat("Run completed at ", format(Sys.time()), "\n")

stopCluster(thecluster)

# hr.cm.results.all.pre is a list of data frames
# rbind them all to one big data frame
hr.cm.results.all <- do.call("rbind", hr.cm.results.all.pre )

# remember to save your data!
# save("hr.cm.results.all", file="hr.cm.results.all.final.rda")
@

\section{Analysis of Simulation Results}
In this section we show how to analyze the simulation
results and fit the model presented in \cite{GreenMartin:2014}.
\subsection{Loading the Data}
We load the data from the simulation runs, add a few
calculations, and sort the data for later use.
<<dataload, eval=FALSE>>=
# load the saved data from the simulation
# load("hr.cm.results.all.final.rda")

# some EDA
head( hr.cm.results.all )
with( hr.cm.results.all, table(n, p, mcd.alpha) )

# sort by dimension, sample size, mcd.alpha
hr.cm.results.all <- hr.cm.results.all[order(hr.cm.results.all$p,
  hr.cm.results.all$n, hr.cm.results.all$mcd.alpha),]
row.names(hr.cm.results.all) <- NULL

# add the asymptotic c and m estimate
# add asymptotic c and m
hr.cm.results.all <- data.frame(
  hr.cm.results.all,
  t(apply( hr.cm.results.all[,c("n","p","mcd.alpha")], 1,
    function(param) unlist(ch99AsymptoticDF(n.obs=param[1],
      p.dim=param[2],mcd.alpha=param[3]))
  )),
  row.names=NULL
)
names(hr.cm.results.all)[7:8] <- c("c.asy","m.asy")

# this snippet groups all the MBP cases together, and
# ensures that MBP sorts before any of the numeric
# MCD fractions
# also adds the log of the difference between the 
# simulated Wishart deg. of freedom m and the 
# asympotic m
thesorter <- function(x) { n <- length(x); x[c(n,1:(n-1))] }
hr.cm.results.all <- within( hr.cm.results.all, {
      # bin mcd.alpha for plotting
  mcd.alpha.bin <- ifelse( mcd.alpha == mbp, "MBP", 
        format( mcd.alpha, digits=3 ))
      # want MBP to always be first
  mcd.alpha.bin <- factor( mcd.alpha.bin, ordered=TRUE,
    levels=thesorter(sort(unique(mcd.alpha.bin)))  )
  log.sim.asy <- log(m)-log(m.asy)
  rm(mbp)
})
head(hr.cm.results.all)

# check for duplicated results
hr.cm.results.all[duplicated(hr.cm.results.all[,c("n","p","mcd.alpha")]),]
@
\subsection{EDA}
Next we 
<<dataeda, eval=FALSE>>=
require(lattice)
require(cggRutils) # needed for splus.theme

xxx <- xyplot( log(m) ~ n | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Simulated Degrees of Freedom against Sample Size\nBy Alpha and Dimension"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

xxx <- xyplot( c ~ n | p, 
        groups = mcd.alpha.bin, 
        data=subset(hr.cm.results.all, n >= 500 & mcd.alpha >= 0.9),
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Simulated Degrees of Freedom against Sample Size\nBy Alpha and Dimension",
    panel = function(x,y,...) {
          panel.xyplot(x,y,...) 
          panel.xyplot(x,x/(x-1),type="l",lty="dotted",col="black")
    }
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( log(m) ~ log(n) | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Simulated Degrees of Freedom against Log Sample Size\nBy Alpha and Dimension"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( log(m.asy) ~ n | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Asymptotic Degrees of Freedom against Sample Size\nBy Alpha and Dimension"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

xxx <- xyplot( log(m.asy) ~ log(n) | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Asymptotic Degrees of Freedom against Log Sample Size\nBy Alpha and Dimension"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( exp(log.sim.asy) ~ n | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Ratio of Sim. DF to Asy. DF against Sample Size\nBy Alpha and Dimension",
    scales=list(y=list(relation="free"))
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( log.sim.asy ~ log(n) | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Log Ratio of Sim. DF to Asy. DF against Log Sample Size\nBy Alpha and Dimension",
    scales=list(y=list(relation="free"))
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

xxx <- xyplot( log.sim.asy ~ n | p, 
        groups = mcd.alpha.bin, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Log Ratio of Sim. DF to Asy. DF against Sample Size\nBy Alpha and Dimension",
    scales=list(y=list(relation="free"))
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

xxx <- xyplot( log.sim.asy ~ n | mcd.alpha.bin, 
  groups = p, 
  data=hr.cm.results.all,
  auto.key=list(space="top",points=TRUE,title="DIMENSION",cex=0.6, columns=3), 
  strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
  main="LOG RATIO OF SIM. DF TO ASY. DF AGAINST SAMPLE SIZE\nBY ALPHA AND DIMENSION",
  scales=list(y=list(relation="free"),x=list(relation="free")),
  panel=function(...) {
    panel.superpose(...)
    panel.abline(h=0, lty="dashed", col="gray")
  },
  xlab="SAMPLE SIZE",
  ylab="LOG RATIO"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


trellis.device(pdf, theme=splus.theme, file="RatioPlot_LogSimAsy_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( exp(log.sim.asy) ~ n | mcd.alpha.bin, 
  groups = p, 
  data=hr.cm.results.all,
  auto.key=list(space="top",points=TRUE,title="DIMENSION",cex=0.6, columns=3), 
  strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
  main="RATIO OF SIM. DF TO ASY. DF AGAINST SAMPLE SIZE\nBY ALPHA AND DIMENSION",
  scales=list(y=list(relation="free"),x=list(relation="free")),
  panel=function(...) {
    panel.superpose(...)
    panel.abline(h=1, lty="dashed", col="gray")
  },
  xlab="SAMPLE SIZE",
  ylab="RATIO"
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

trellis.device(pdf, theme=splus.theme, file="RatioPlot_SimAsy_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()
@

\subsection{Fit model}
<<datasmall, eval=FALSE>>=
# fit a model where log of ratio decreases like c/n^d, for a power of n that depends on the alpha
# and some constant that is a function of alpha, p

nls.final <- nls( log.sim.asy ~  ( b0 + b1*mcd.alpha + b2*p  )/( n^(b4 + b5*mcd.alpha) ),
  data = hr.cm.results.all,
  start = c(b0 = 0, b1 = 1, b2 = 0, b4 = 0, b5 = 1)
)
summary(nls.final)

hr.cm.results.all$log.pred.asy <- predict( nls.final, 
  newdata=hr.cm.results.all[,c("mcd.alpha","p","n")] )
hr.cm.results.all <- within(hr.cm.results.all, 
  {
    m.pred <- m.asy * exp(log.pred.asy)
    log.sim.pred <- log(m)-log(m.pred)
  }
)




xxx <- xyplot( log.pred.asy ~ log.sim.asy | p * mcd.alpha.bin,
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Predicted ratio vs observed ratio",
    scales=list(y=list(relation="free"),x=list(relation="free")),
    page=function(n) Sys.sleep(5),
    layout=c(6,3),
    panel=function(...) {
    panel.xyplot(...)
    panel.abline(c(0,1), col="gray", lty="dotted")
    }
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

trellis.device(pdf, theme=splus.theme, file="Log_Predicted_m_Vs_Log_Observed_m_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


xxx <- xyplot( m.pred ~ m | p * mcd.alpha.bin,
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Predicted m vs observed m",
    scales=list(y=list(relation="free"),x=list(relation="free")),
    page=function(n) Sys.sleep(5),
    layout=c(6,3),
    panel=function(...) {
    panel.xyplot(...)
    panel.abline(c(0,1), col="gray", lty="dotted")
    }
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()

trellis.device(pdf, theme=splus.theme, file="Predicted_m_Vs_Observed_m_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()



xxx <- xyplot( log.sim.pred ~ n | mcd.alpha.bin, 
        groups = p, 
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Log Ratio of Sim. DF to Predicted DF against Sample Size\nBy Alpha and Dimension",
    scales=list(y=list(relation="free"),x=list(relation="free")),
    panel=function(...) {
    panel.superpose(...)
    panel.abline(h=0, lty="dotted", col="gray")
    }
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


trellis.device(pdf, theme=splus.theme, file="RatioPlot_LogSimPred_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()



xxx <- xyplot( log.sim.pred ~ log(n),
        data=hr.cm.results.all,
        auto.key=list(space="right",points=TRUE), 
        strip=strip.custom(strip.names=FALSE,strip.levels=TRUE),
    main="Log Ratio of Sim. DF to Predicted DF against Sample Size",
    scales=list(y=list(relation="free"),x=list(relation="free")),
    panel=function(...) {
    panel.xyplot(...)
    panel.abline(h=0, lty="dotted", col="gray")
    }
)
trellis.device(windows, theme=splus.theme)
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()


trellis.device(pdf, theme=splus.theme, file="RatioPlot_LogSimPred_UNSTRATIFIED_final.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- 1:10
trellis.par.set("superpose.symbol",tss)
print(xxx)
dev.off()
@

\bibliographystyle{plainnat}
\bibliography{HardinRockeExtension}
\end{document}
