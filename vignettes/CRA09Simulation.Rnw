\documentclass[11pt]{article}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}

%\VignetteIndexEntry{Extending Cerioli et al. (2009)---Simulation}
%\VignetteDepends{HardinRockeExtension}
\SweaveOpts{prefix.string=hr, eps=FALSE, pdf=TRUE, strip.white=true}
\SweaveOpts{width=6, height=4.1}

%\usepackage{amsmath}
%\usepackage{amsfonts}% \mathbb
%\usepackage{mathtools}% -> \floor, \ceil
\usepackage[utf8]{inputenc}
%% The following is partly R's share/texmf/Rd.sty
\usepackage{color}
\usepackage{hyperref}
\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{Red}{rgb}{0.7,0,0}
\hypersetup{%
  hyperindex,%
  colorlinks={true},%
  pagebackref,%
  linktocpage,%
  plainpages={false},%
  linkcolor={Blue},%
  citecolor={Blue},%
  urlcolor={Red},%
  pdfstartview={XYZ null null 1},%
  pdfview={XYZ null null null},%
}

\usepackage{natbib}
\usepackage[noae]{Sweave}
%----------------------------------------------------
%\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
%\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
%\DeclareMathOperator{\sign}{sign}
%\newcommand{\abs}[1]{\left| #1 \right|}
%\newtheorem{definition}{Definition}
%\newcommand{\byDef}{\mathrm{by\ default}}
%\newcommand{\R}{{\normalfont\textsf{R}}{}}
%\newcommand{\texttt}[1]{\texttt{#1}}
%\newcommand*{\pkg}[1]{\texttt{#1}}
%\newcommand*{\CRANpkg}[1]{\href{http://CRAN.R-project.org/package=#1}{\pkg{#1}}}

%----------------------------------------------------
\begin{document}
%\setkeys{Gin}{width=0.9\textwidth}
%\setlength{\abovecaptionskip}{-5pt}

\title{Extending Cerioli et al. (2009)---Simulation Work}
\author{Christopher~G. Green}
\maketitle
%\tableofcontents
<<init, echo=FALSE>>=
@

\section{Introduction}
This vignette shows how to use the function
\texttt{table13sim.parallel} to replicate and extend the 
Monte Carlo simulation performed in 
\cite{CerioliRianiAtkinson:2009} to examine the accuracy
of outlier tests calculated using MCD-based Mahalanobis 
distances.

\cite{CerioliRianiAtkinson:2009} focused on the 
maximum breakdown point case of the MCD, and
\cite{GreenMartin:2014b} extended this to 
variants of the MCD (using more of the observations) 
and several other robust estimates of dispersion.

We assume the reader can set up a cluster
using the \texttt{parallel} package, but this
is not necessary: one can create a cluster with
a single node.

Note that all code blocks in the vignette are marked
as ``do not evaluate'' to avoid running long simulations
during package checks. In the \texttt{R} code file 
resulting from running \texttt{Stangle} on the vignette
source, you will need to uncomment all the \texttt{R}
code to actually run the simulation.

\section{Setup}
First, we load some required packages and take care of some performance
tuning. The simulation requires the \texttt{CerioliOutlierDetection}
package as well as the \texttt{parallel} package. We also load the
\texttt{RhpcBLASctl} package to force the use of single-threaded BLAS,
if possible: with a multi-threaded BLAS on a multi-core machine, the
cluster ``nodes'' may impede each other. We want each worker to have
the node to itself for maximum efficiency.
<<setup, eval=FALSE>>=
require( RhpcBLASctl             )
require( parallel                )
require( CerioliOutlierDetection )
require( HardinRockeExtension    )

# force single-threaded BLAS if possible
omp_set_num_threads(1)
# print warnings as they occur
options(warn=1)
@

Create a cluster using one of the \texttt{makeXXcluster}
functions from the \texttt{parallel} package. On Windows,
\texttt{makePSOCKcluster} is the only available option.
We assume 10 nodes here. \texttt{table13sim.parallel} will 
distribute the work within a simulation run across 
the cluster.

The \texttt{useXDR} option should be set to FALSE
on little endian machines for efficiency.
<<makecluster, eval=FALSE>>=
thecluster <- makePSOCKcluster(10,
  outfile="table1_cluster_socket.log",
  useXDR=FALSE # these are all little endian machines
)
@

We initialize the cluster random number generator
with a seed; this makes it possible for you to 
replicate our numbers and the resulting figures.
<<reproduce, eval=FALSE>>=
# make reproducible
clusterSetRNGStream(cl = thecluster, 2016)
@

Now we initialize each cluster node using
\texttt{clusterEvalQ}. Each node needs a copy
of the two libraries we use for the simulation,
and we create a logfile for each node, tagged
with the process ID and machine name of the 
worker process running on the node.

Cerioli et al. used 50000 simulation runs. We set 
a block size of 250 to manage the memory use on our
machine; this will allocate 250 runs to each cluster
node.
<<clusterinit, eval=FALSE>>=
N.SIM <- 50000
B.SIM <- 250

# initialize each node
tmp.rv <- clusterEvalQ( cl = thecluster, {

  #require(abind,                   quietly=TRUE)
  #require(rrcov,                   quietly=TRUE)
  #require(mvtnorm,                 quietly=TRUE)
  #require(timeSeries,              quietly=TRUE)
  require(CerioliOutlierDetection, quietly=TRUE)
  require(HardinRockeExtension,    quietly=TRUE)
  require( RhpcBLASctl             )

  # force single-threaded BLAS if possible
  omp_set_num_threads(1)
  # print warnings as they occur
  options(warn=1)

  # sleep for 30 seconds to allow for other output to be flushed
  my.pid <- Sys.getpid()
  my.nodename <- Sys.info()["nodename"]
  cat("My pid is ", my.pid, " on node ", my.nodename, "\n")
  logfile <- paste("table1_logfile_",my.nodename,"_",my.pid,".txt",sep="")
  Sys.sleep(30)
  cat("Initialized\n\n", file=logfile)
  cat("My pid is ", my.pid, "on node ", my.nodename, "\n",file=logfile,append=TRUE)

  invisible(NULL)
})
@

Next, we generate the cases we will want to run. Each case
consists of a dimension $p$ and a sample size $n$.  We use 
a superset of the cases run in \cite{CerioliRianiAtkinson:2009}
to expand their study.

We chose to order the cases by decreasing sample size so that
the most ``expensive'' cases would run first on our cluster; this
is not required.

Finally, we rotate the matrix of cases to a data frame for use
with lapply and variants (recall that a data frame is a list of
its columns).
<<buildcases, eval=FALSE>>=
all.params <- expand.grid(
  list(p=seq(2,20,2), n=c(50,75,100,150,200,300,500,1000)))
# adding more coverage for small sample sizes
all.params <- rbind( all.params, within( 
  expand.grid(list(p=seq(2,20,2),
    ratio=c( 3,5,7,9,11 ) )), 
  {
    n <- p * ratio
    rm(ratio)
  }
))
# remove any duplicates
all.params <- unique(all.params)
# try to order by the size of the problem
all.params <- all.params[ order( all.params$p * all.params$n, decreasing=TRUE), ]
all.params <- data.frame(t(as.matrix( all.params )))
names( all.params ) <- sprintf("V%02d",seq(ncol(all.params)))
cat("Parameter matrix size:\n")
print( dim(all.params) )
cat("Parameters:\n")
print( all.params )
cat("***\n")
@

\section{Simulation Runs}
Now we run the simulation. We distribute the work of each
case across the cluster. 

The results of each case are saved to separate RDA files.
We also save the random seed after completion of each case.
Since this simulation can take weeks (or months if you have
very few nodes), this gives us some protection against 
interruptions to our cluster---we do not have to redo the
calculations we have finished, and can restart the random
number generator at the last saved state. We store the
sample size and dimension as attributes for later convenience.

Remember to stop your cluster when you're done.
<<runsim, eval=FALSE>>=
# using lapply here to prevent simplification of the
# results 

cat("Starting run at ", format(Sys.time()), "\n")

table1.results.final <- lapply(all.params,
  function(pn,clst,ns,bs) {
    cat("Trial p = ",pn[1]," n = ",pn[2],"at ", format(Sys.time()), "\n")
    results <- table13sim.parallel(cl=clst, p = pn[1], nn = pn[2], 
      N=ns, B=bs, lgf=logfile)
    attr(results,"p") <- pn[1]
    attr(results,"n") <- pn[2]

    save("results",
      file=sprintf("table1_results_final_p%02d_n%04d.rda",pn[1],pn[2]))
    save(".Random.seed",
      file=sprintf("table1_randomseedpost_p%02d_n%04d.rda",pn[1],pn[2]))
    invisible(TRUE)
  }, 
  clst=thecluster, ns=N.SIM, bs=B.SIM
)

cat("Run completed at ", format(Sys.time()), "\n")

stopCluster(thecluster)
@

\section{Analysis of Simulation Results}
In this section we show how to analyze the simulation
results and fit the model presented in \cite{GreenMartin:2014b}.
\subsection{Loading the Data}
Since we saved the results of each case to separate files, we need
to load all of those files and combine the results to one big 
data set.

First, we create a data structure, \texttt{tmpout}, to store
the results from each case/file. 
<<data-step-01a, eval=FALSE>>=
library( cggRutils )
library( Hmisc )
library( lattice )
tmpout <- list(my.a = 128, my.b = 74, result=NULL)

tmpout$result <- with(tmpout, 
  list(
    p=rep(NA, my.a * my.b),
    n=rep(NA, my.a * my.b),
    method=rep("", my.a * my.b),
    mean010=rep(NA, my.a * my.b),
    sd010=rep(NA, my.a * my.b),
    mean025=rep(NA, my.a * my.b),
    sd025=rep(NA, my.a * my.b),
    mean050=rep(NA, my.a * my.b),
    sd050=rep(NA, my.a * my.b)
  )
)
@

Next we load each file and 
copy the data to our data structure. We calculate 
the average false positive rate and the variability
of the false positive rate along the way.
<<data-step-01b, eval=FALSE>>=
flz <- dir(pattern="table1_results_final_.*\\.rda")
for ( i in seq(along=flz) ) {
  ind <- seq.int(tmpout$my.b) + (i-1) * tmpout$my.b
  load(flz[i])
  
  tmpout$result$p[ind]          <- attr(results,"p")
  tmpout$result$n[ind]          <- attr(results,"n")
  tmp.mm <- apply(results,c(2,3),mean)
  tmp.ss <- apply(results,c(2,3),sd)
  tmpout$result$mean010[ind]    <- tmp.mm[,"alpha0.01"]
  tmpout$result$sd010[ind]      <- tmp.ss[,"alpha0.01"]
  tmpout$result$mean025[ind]    <- tmp.mm[,"alpha0.025"]
  tmpout$result$sd025[ind]      <- tmp.ss[,"alpha0.025"]
  tmpout$result$mean050[ind]    <- tmp.mm[,"alpha0.05"]
  tmpout$result$sd050[ind]      <- tmp.ss[,"alpha0.05"]
  tmpout$result$method[ind]     <- dimnames(results)[[2]]
}
@

Now we can convert \texttt{tmpout} to a data frame. We check
for missing data to catch any errors building the data set 
(e.g., incorrect number of fields, incorrect number of data sets).
Finally, we add a column for the ratio $n/p$ as well as a binned
version of the ratio.
<<data-step-01c, eval=FALSE>>=
tmpout$result <- data.frame(tmpout$result)
stopifnot(nrow(subset( tmpout$result, is.na(mean010) | is.na(sd010) | 
  is.na(mean025) | is.na(sd025) | is.na(mean050) | is.na(sd050)))==0)

# 2015-02-16 add ratio n/p
tmpout$result$noverp <- tmpout$result$n / tmpout$result$p 
tmpout$result$noverp.cut <- cut( tmpout$result$noverp, breaks = c(0,5,10,20,Inf) )
levels( tmpout$result$noverp.cut ) <- c("(0,5]","(5,10]","(10,20]","> 20")
@

Next we create versions of the results that have the results for each sample size 
in columns.
<<data-step-01d, eval=FALSE>>=
# reshape with values of n across the top
tmpout$reshaped$mean010 <- reshape(
  subset(tmpout$result, 
    select=-c(sd010,sd025,sd050,mean025,mean050,noverp,noverp.cut)),
  direction="wide",
  v.names="mean010",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$mean010 )
oldn <- gsub("mean010\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$mean010 ) <- oldn
head( tmpout$reshaped$mean010  )

tmpout$reshaped$mean025 <- reshape(
  subset(tmpout$result, 
    select=-c(sd010,sd025,sd050,mean010,mean050,noverp,noverp.cut)),
  direction="wide",
  v.names="mean025",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$mean025 )
oldn <- gsub("mean025\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$mean025 ) <- oldn
head( tmpout$reshaped$mean025  )

tmpout$reshaped$mean050 <- reshape(
  subset(tmpout$result, 
    select=-c(sd010,sd025,sd050,mean025,mean010,noverp,noverp.cut)),
  direction="wide",
  v.names="mean050",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$mean050 )
oldn <- gsub("mean050\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$mean050 ) <- oldn
head( tmpout$reshaped$mean050  )



tmpout$reshaped$sd010 <- reshape(
  subset(tmpout$result, 
    select=-c(mean010,mean025,mean050,sd025,sd050,noverp,noverp.cut)),
  direction="wide",
  v.names="sd010",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$sd010 )
oldn <- gsub("sd010\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$sd010 ) <- oldn
head( tmpout$reshaped$sd010 )


tmpout$reshaped$sd025 <- reshape(
  subset(tmpout$result, 
    select=-c(mean010,mean025,mean050,sd010,sd050,noverp,noverp.cut)),
  direction="wide",
  v.names="sd025",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$sd025 )
oldn <- gsub("sd025\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$sd025 ) <- oldn
head( tmpout$reshaped$sd025 )

tmpout$reshaped$sd050 <- reshape(
  subset(tmpout$result, 
    select=-c(mean010,mean025,mean050,sd025,sd010,noverp,noverp.cut)),
  direction="wide",
  v.names="sd050",
  idvar=c("p","method"),
  timevar="n"
)
oldn <- names(tmpout$reshaped$sd050 )
oldn <- gsub("sd050\\.","n = ",oldn)
oldn <- gsub("method","Method",oldn)
oldn <- gsub("p","v",oldn)
names(tmpout$reshaped$sd050 ) <- oldn
head( tmpout$reshaped$sd050 )
@

The data set actually contains results from replicating Tables 1
and 3 of \cite{CerioliRianiAtkinson:2009}; we split those out into
separate data sets.
<<data-step-01e, eval=FALSE>>=
# split to table1 and table3 results
tmpout.t1 <- tmpout
tmpout.t1$result <- subset( tmpout$result, grepl("\\.T1",method) )
tmpout.t1$result$method <- tmpout.t1$result$method[drop=TRUE]
levels(tmpout.t1$result$method) <- gsub("\\.T1$","",levels(tmpout.t1$result$method))

lvs <- c(
  "MCD75.GM.NOSS","MCD75.GM","MCD75.HR.NOSS","MCD75.HR","MCD75.CHI",
  "MCD95.GM.NOSS","MCD95.GM","MCD95.HR.NOSS","MCD95.HR","MCD95.CHI",
  "MCDMBP.GM.NOSS","MCDMBP.GM","MCDMBP.HR.NOSS","MCDMBP.HR","MCDMBP.CHI",
  "OGK",
  "RMCD75","RMCD95","RMCDMBP",
  "ROGK",
  "SEST.BS","SEST.RK"
)
lvs.sorted <- c(
  "MCDMBP.CHI","MCDMBP.HR","MCDMBP.GM","RMCDMBP","MCDMBP.HR.NOSS","MCDMBP.GM.NOSS",
  "MCD75.CHI","MCD75.HR","MCD75.GM","RMCD75","MCD75.HR.NOSS","MCD75.GM.NOSS",
  "MCD95.CHI","MCD95.HR","MCD95.GM","RMCD95","MCD95.HR.NOSS","MCD95.GM.NOSS",
  "OGK","ROGK","SEST.BS","SEST.RK"
)
tmpout.t1$my.b <- length(lvs)

for (var in c("mean010","mean025","mean050","sd010","sd025","sd050")) {
  tmpout.t1$reshaped[[var]] <- subset( tmpout$reshaped[[var]], grepl("\\.T1",Method) )
  tmpout.t1$reshaped[[var]]$Method <- tmpout.t1$reshaped[[var]]$Method[drop=TRUE]
  levels(tmpout.t1$reshaped[[var]]$Method) <- lvs
  tmpout.t1$reshaped[[var]]$Method <- ordered( tmpout.t1$reshaped[[var]]$Method,
    levels=lvs.sorted
  )
  tmpout.t1$reshaped[[var]] <- tmpout.t1$reshaped[[var]][ 
    order(tmpout.t1$reshaped[[var]]$v, tmpout.t1$reshaped[[var]]$Method), ]
}

######################################################################

tmpout.t3 <- tmpout
tmpout.t3$result <- subset( tmpout$result, grepl("\\.T3",method) )
tmpout.t3$result$method <- tmpout.t3$result$method[drop=TRUE]
levels(tmpout.t3$result$method) <- gsub("\\.T3$","",levels(tmpout.t3$result$method))

lvs <- c(
  "MCD75.GM.NOSS","MCD75.GM.NOSS.ALT","MCD75.GM","MCD75.GM.ALT",
  "MCD75.HR.NOSS","MCD75.HR.NOSS.ALT","MCD75.HR","MCD75.HR.ALT",
  "MCD75.CHI","MCD75.CHI.ALT",
  "MCD95.GM.NOSS","MCD95.GM.NOSS.ALT","MCD95.GM","MCD95.GM.ALT",
  "MCD95.HR.NOSS","MCD95.HR.NOSS.ALT","MCD95.HR","MCD95.HR.ALT",
  "MCD95.CHI","MCD95.CHI.ALT",
  "MCDMBP.GM.NOSS","MCDMBP.GM.NOSS.ALT","MCDMBP.GM","MCDMBP.GM.ALT",
  "MCDMBP.HR.NOSS","MCDMBP.HR.NOSS.ALT","MCDMBP.HR","MCDMBP.HR.ALT",
  "MCDMBP.CHI","MCDMBP.CHI.ALT",
  "OGK","OGK.ALT",
  "RMCD75.CH","RMCD75.CH.ALT","RMCD75","RMCD75.ALT",
  "RMCD95.CH","RMCD95.CH.ALT","RMCD95","RMCD95.ALT",
  "RMCDMBP.CH","RMCDMBP.CH.ALT","RMCDMBP","RMCDMBP.ALT",
  "ROGK.CH","ROGK.CH.ALT","ROGK","ROGK.ALT",
  "SEST.BS","SEST.BS.ALT","SEST.RK","SEST.RK.ALT"
)
lvs.sorted <- c(
  "MCDMBP.CHI","MCDMBP.HR","MCDMBP.GM","RMCDMBP","RMCDMBP.CH","MCDMBP.HR.NOSS","MCDMBP.GM.NOSS",
  "MCDMBP.CHI.ALT","MCDMBP.HR.ALT","MCDMBP.GM.ALT","RMCDMBP.ALT","RMCDMBP.CH.ALT","MCDMBP.HR.NOSS.ALT",
  "MCDMBP.GM.NOSS.ALT","MCD75.CHI","MCD75.HR","MCD75.GM","RMCD75","RMCD75.CH","MCD75.HR.NOSS",
  "MCD75.GM.NOSS","MCD75.CHI.ALT","MCD75.HR.ALT","MCD75.GM.ALT","RMCD75.ALT","RMCD75.CH.ALT",
  "MCD75.HR.NOSS.ALT","MCD75.GM.NOSS.ALT","MCD95.CHI","MCD95.HR","MCD95.GM","RMCD95","RMCD95.CH",
  "MCD95.HR.NOSS","MCD95.GM.NOSS","MCD95.CHI.ALT","MCD95.HR.ALT","MCD95.GM.ALT","RMCD95.ALT",
  "RMCD95.CH.ALT","MCD95.HR.NOSS.ALT","MCD95.GM.NOSS.ALT","OGK","ROGK","ROGK.CH","SEST.BS",
  "SEST.RK","OGK.ALT","ROGK.ALT","ROGK.CH.ALT","SEST.BS.ALT","SEST.RK.ALT"
)

tmpout.t3$my.b <- length(lvs)

for (var in c("mean010","mean025","mean050","sd010","sd025","sd050")) {
  tmpout.t3$reshaped[[var]] <- subset( tmpout$reshaped[[var]], grepl("\\.T3",Method) )
  tmpout.t3$reshaped[[var]]$Method <- tmpout.t3$reshaped[[var]]$Method[drop=TRUE]
  levels(tmpout.t3$reshaped[[var]]$Method) <- lvs
  tmpout.t3$reshaped[[var]]$Method <- ordered( tmpout.t3$reshaped[[var]]$Method,
    levels=lvs.sorted
  )
  tmpout.t3$reshaped[[var]] <- tmpout.t3$reshaped[[var]][ 
    order(tmpout.t3$reshaped[[var]]$v, tmpout.t3$reshaped[[var]]$Method), ]
}

tmpout.t1$result$mean010.scaled <- tmpout.t1$result$mean010/0.01
tmpout.t1$result$mean025.scaled <- tmpout.t1$result$mean025/0.01
tmpout.t1$result$mean050.scaled <- tmpout.t1$result$mean050/0.01

tmpout.t3$result$mean010.scaled <- tmpout.t3$result$mean010/0.01
tmpout.t3$result$mean025.scaled <- tmpout.t3$result$mean025/0.01
tmpout.t3$result$mean050.scaled <- tmpout.t3$result$mean050/0.01

rm(lvs,lvs.sorted,oldn,flz,i,tmp.mm,tmp.ss)
@

\subsection{Analysis for Individual Hypothesis}
\subsubsection{Tables}
We use the reshaped data sets and the \texttt{Hmisc} package to 
create \LaTeX tables of the average false positive rate and the 
variability of the false positive rate for the three significance
levels used ($0.01$, $0.025$, and $0.05$). For brevity, we just 
show the $0.01$ cases; the others are produced the same way with
the \texttt{mean025}, \texttt{mean050}, etc., data sets.

This is Table 1 in \cite{GreenMartin:2014b}.
<<table1-step-01a, eval=FALSE>>=
table.data <- subset( tmpout.t1$reshaped$mean010, !grepl("NOSS",Method) )
table.data$Method <- table.data$Method[drop=TRUE]

## mean, 0.01 case
tmpout.t1$caption <- paste(
  "Size of the individual multivariate outlier tests at the $\\alpha = 0.01$ notional",
  "level for several estimates of dispersion. ",
  "Key: HR = MCD estimator with original Hardin-Rocke distributional approximation;",
  "GM = MCD estimator with modified Green-Martin distributional approximation;",
  "RMCD = MCD with one-step reweighting; ROGK = OGK with one-step reweighting;",
  "S-BISQ = S-estimate with using bisquare $\\rho$ function; S-ROCKE = Rocke's S-estimate."
)
zzz <- latex(table.data[,-c(1,2)], 
      file="table1.final.means01.tex",
      caption=tmpout.t1$caption, 
  label="Table:Table1:Final:010",
  title="",
  rowname=table.data$Method,
  rowlabel="Method",
  dec=3,
  rgroup = paste("Dimension =",as.character(unique(table.data$v))),
  n.rgroup = rep(nlevels(table.data$Method),length(unique(table.data$v))),
  longtable=TRUE,
  size="small"
)
@

This is Table 2 in \cite{GreenMartin:2014b}.
<<table1-step-01b, eval=FALSE>>=
## sd, 0.01 case
table.data <- subset( tmpout.t1$reshaped$sd010, !grepl("NOSS",Method) )
table.data$Method <- table.data$Method[drop=TRUE]

tmpout.t1$caption <- paste(
  "Monte Carlo standard deviations for the individual multivariate outlier tests at the ",
  "$\\alpha = 0.01$ notional level for several estimates of dispersion. Standard errors ",
  "for the test sizes presented in Table \\ref{Table:Table1:Final:010} can be obtained by ",
  "dividing corresponding entries in this table by $\\sqrt{50000}$."
)
zzz <- latex(table.data[,-c(1,2)], 
      file="table1.final.sds01.tex",
      caption=tmpout.t1$caption, 
  label="Table:Table1:Final:SDS:010",
  title="",
  rowname=table.data$Method,
  rowlabel="Method",
  dec=3,
  rgroup = paste("Dimension =",as.character(unique(table.data$v))),
  n.rgroup = rep(nlevels(table.data$Method),length(unique(table.data$v))),
  longtable=TRUE,
  size="small"
)
rm(zzz)
@

\subsubsection{Figures}
Here we produce all the figures used in \cite{GreenMartin:2014b}
for the analysis of the individual hypothesis case. These plots
largely share the same structure, just with different subsets of
the data (corresponding to different estimators.

The code below produces figures for the $0.01$ significance level
case; the code for other significance levels is similar and is omitted
to save space.

Figure 1 of \cite{GreenMartin:2014b}.
<<table1-step-02a, eval=FALSE>>=
# MCD with chi-square 
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("MCDMBP.RAW","MCD75.RAW","MCD95.RAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75","MCD95","MCDMBP")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_MCD_ChiSq_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 2 of \cite{GreenMartin:2014b}.
<<table1-step-02b, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("RMCDMBP","RMCD75","RMCD95"),
      drop.unused.levels=TRUE)
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_RMCD_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 3 of \cite{GreenMartin:2014b}.
<<table1-step-02c, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("MCDMBP.HRRAW","MCD75.HRRAW","MCD95.HRRAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.HR","MCD95.HR","MCDMBP.HR")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_MCDHR_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 4 of \cite{GreenMartin:2014b}.
<<table1-step-02d, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("MCDMBP.GMRAW","MCD75.GMRAW","MCD95.GMRAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.GM","MCD95.GM","MCDMBP.GM")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_MCDGM_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 5 of \cite{GreenMartin:2014b}.
<<table1-step-02m, eval=FALSE>>=
# make a plot showing how the MCD methods compare for dimension 10
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, (p == 10) & (
    method %in% c("MCDMBP.RAW","MCDMBP.GMRAW","MCDMBP.HRRAW","RMCDMBP",
          "MCD75.RAW","MCD75.GMRAW","MCD75.HRRAW","RMCD75",
          "MCD95.RAW","MCD95.GMRAW","MCD95.HRRAW","RMCD95") ),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.GM","MCD75.HR","MCD75","MCD95.GM",
  "MCD95.HR","MCD95","MCDMBP.GM","MCDMBP.HR","MCDMBP","RMCD75",
  "RMCD95","RMCDMBP")
names(plotdata)[1] <- "DIM"
plotdata$mcdalpha <- plotdata$method
lvs <- levels(plotdata$mcdalpha) 
lvs[grep("MBP",lvs)] <- "MBP"
lvs[grep("75",lvs)] <- "0.75"
lvs[grep("95",lvs)] <- "0.95"
levels(plotdata$mcdalpha) <- lvs
plotdata$mcdalpha <- factor(plotdata$mcdalpha, 
  ordered=TRUE, levels=c("MBP","0.75","0.95"))

plotdata$mcdvariant <- plotdata$method
lvs <- levels(plotdata$mcdvariant) 
lvs[grep("GM$"           ,lvs)] <- "MCD (GM)"
lvs[grep("HR$"           ,lvs)] <- "MCD (HR)"
lvs[grep("^RMCD"         ,lvs)] <- "RMCD (CHISQ.)"
lvs[grep("^MCD[79]5$"    ,lvs)] <- "MCD (CHISQ.)"
lvs[grep("^MCDMBP$"      ,lvs)] <- "MCD (CHISQ.)"
levels(plotdata$mcdvariant) <- lvs

theplot <- xyplot( mean010.scaled ~ n | mcdalpha,
  data = plotdata,
  groups = mcdvariant,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "DIMENSION = 10",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="free"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  layout=c(3,1),
  aspect = 1,
  auto.key = list(space="bottom", points = TRUE, columns = 2, padding.text = 2)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_Compare_MCD_v10_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 6 of \cite{GreenMartin:2014b}.
<<table1-step-02n, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("OGK","ROGK"),
      drop.unused.levels=TRUE)
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="free"), x=list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_OGK_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 7 of \cite{GreenMartin:2014b}.
<<table1-step-02q, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t1$result, 
    method %in% c("SEST.BS","SEST.RK"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("BISQUARE S-EST.","ROCKE S-EST")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x=list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Individual_BISQ_ROCKE_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

\subsection{Analysis for Intersection Hypothesis}
\subsubsection{Tables}
These work like the tables for the individual hypothesis case.
Once again we just show the $0.01$ cases; the others are produced 
the same way with
the \texttt{mean025}, \texttt{mean050}, etc., data sets.

This is Table 3 in \cite{GreenMartin:2014b}.
<<table3-step-01a, eval=FALSE>>=
table.data <- subset( tmpout.t3$reshaped$mean010, !grepl("NOSS",Method) )
table.data$Method <- table.data$Method[drop=TRUE]

## mean, 0.01 case
tmpout.t3$caption <- paste(
  "Size of the intersection multivariate outlier tests at the $\\alpha = 0.01$ ",
  "notional level for several estimates of dispersion. ",
  "Key: HR = MCD estimator with original Hardin-Rocke distributional approximation;",
  "GM = MCD estimator with modified Green-Martin distributional approximation;",
  "RMCD = MCD with one-step reweighting;",
  "RMCD.CH = RMCD with Bonferroni-corrected reweighting;",
  "ROGK = OGK with one-step reweighting;",
  "ROGK.CH = ROGK with Bonferroni-corrected reweighting;",
  "S-BISQ = S-estimate with using bisquare $\\rho$ function;",
  "S-ROCKE = Rocke's S-estimate."
)
zzz <- latex(table.data[,-c(1,2)], 
      file="table3.final.means01.tex",
      caption=tmpout.t3$caption, 
  label="Table:Table3:Final:010",
  title="",
  rowname=table.data$Method,
  rowlabel="Method",
  dec=3,
  rgroup = paste("Dimension =",as.character(unique(table.data$v))),
  n.rgroup = rep(nlevels(table.data$Method),length(unique(table.data$v))),
  longtable=TRUE,
  size="small"
)
rm(zzz)
@

This is Table 4 in \cite{GreenMartin:2014b}.
<<table3-step-01b, eval=FALSE>>=
table.data <- subset( tmpout.t3$reshaped$sd010, !grepl("NOSS",Method) )
table.data$Method <- table.data$Method[drop=TRUE]

## sd, 0.01 case
tmpout.t3$caption <- paste(
  "Monte Carlo standard deviations for the intersection multivariate outlier tests",
  "at the $\\alpha = 0.01$ notional level for several estimates of dispersion. ",
  "Standard errors for the test sizes presented in Table \\ref{Table:Table3:Final:010}",
  "can be obtained by dividing corresponding entries in this table by $\\sqrt{50000}$."
)
zzz <- latex(table.data[,-c(1,2)], 
      file="table3.final.sds01.tex",
      caption=tmpout.t3$caption, 
  label="Table:Table3:Final:SDS:010",
  title="",
  rowname=table.data$Method,
  rowlabel="Method",
  dec=3,
  rgroup = paste("Dimension =",as.character(unique(table.data$v))),
  n.rgroup = rep(nlevels(table.data$Method),length(unique(table.data$v))),
  longtable=TRUE,
  size="small"
)
rm(zzz)
@

\subsubsection{Figures}
Here we produce all the figures used in \cite{GreenMartin:2014b}
for the analysis of the intersection hypothesis case. As before,
these plots largely share the same structure, just with different 
subsets of the data (corresponding to different estimators.

The code below produces figures for the $0.01$ significance level
case; the code for other significance levels is similar and is omitted
to save space.

Figure 8 of \cite{GreenMartin:2014b}.
<<table3-step-02a, eval=FALSE>>=
# MCD with chi-square 
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("MCDMBP.RAW","MCD75.RAW","MCD95.RAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75","MCD95","MCDMBP")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_MCD_ChiSq_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 9 of \cite{GreenMartin:2014b}.
<<table3-step-02b, eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("RMCDMBP","RMCD75","RMCD95"),
      drop.unused.levels=TRUE)
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_RMCD_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 10 of \cite{GreenMartin:2014b}.
<<table3-step02c,eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("RMCDMBP.CH","RMCD75.CH","RMCD95.CH"),
      drop.unused.levels=TRUE)
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_RMCDCH_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 11 of \cite{GreenMartin:2014b}.
<<table3-step02d,eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("MCDMBP.HRRAW","MCD75.HRRAW","MCD95.HRRAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.HR","MCD95.HR","MCDMBP.HR")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_MCDHR_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 12 of \cite{GreenMartin:2014b}.
<<table3-step02e,eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("MCDMBP.GMRAW","MCD75.GMRAW","MCD95.GMRAW"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.GM","MCD95.GM","MCDMBP.GM")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_MCDGM_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 13 of \cite{GreenMartin:2014b}.
<<table3-step02n,eval=FALSE>>=# make a plot showing how the MCD methods compare for dimension 10
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, (p == 10) & (
    method %in% c("MCDMBP.RAW","MCDMBP.GMRAW","MCDMBP.HRRAW","RMCDMBP","RMCDMBP.CH",
          "MCD75.RAW","MCD75.GMRAW","MCD75.HRRAW","RMCD75","RMCD75.CH",
          "MCD95.RAW","MCD95.GMRAW","MCD95.HRRAW","RMCD95","RMCD95.CH") ),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("MCD75.GM","MCD75.HR","MCD75","MCD95.GM","MCD95.HR",
  "MCD95","MCDMBP.GM","MCDMBP.HR","MCDMBP","RMCD75.CH","RMCD75","RMCD95.CH",
  "RMCD95","RMCDMBP.CH","RMCDMBP"
)
names(plotdata)[1] <- "DIM"
plotdata$mcdalpha <- plotdata$method
lvs <- levels(plotdata$mcdalpha) 
lvs[grep("MBP",lvs)] <- "MBP"
lvs[grep("75",lvs)] <- "0.75"
lvs[grep("95",lvs)] <- "0.95"
levels(plotdata$mcdalpha) <- lvs
plotdata$mcdalpha <- factor(plotdata$mcdalpha, 
  ordered=TRUE, levels=c("MBP","0.75","0.95"))

plotdata$mcdvariant <- plotdata$method
lvs <- levels(plotdata$mcdvariant) 
lvs[grep("GM$"           ,lvs)] <- "MCD (GM)"
lvs[grep("HR$"           ,lvs)] <- "MCD (HR)"
lvs[grep("^RMCD.*\\.CH$"  ,lvs)] <- "RMCDCH (CHISQ.)"
lvs[grep("^RMCD[79]5$"   ,lvs)] <- "RMCD (CHISQ.)"
lvs[grep("^MCD[79]5$"    ,lvs)] <- "MCD (CHISQ.)"
lvs[grep("^RMCDMBP$"     ,lvs)] <- "RMCD (CHISQ.)"
lvs[grep("^MCDMBP$"      ,lvs)] <- "MCD (CHISQ.)"
levels(plotdata$mcdvariant) <- lvs

theplot <- xyplot( mean010.scaled ~ n | mcdalpha,
  data = plotdata,
  groups = mcdvariant,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "DIMENSION = 10",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="free"), x = list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  layout=c(3,1),
  aspect = 1,
  auto.key = list(space="bottom", points = TRUE, columns = 3)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_Compare_MCD_v10_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 14 of \cite{GreenMartin:2014b}.
<<table3-step02o,eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("OGK","ROGK","ROGK.CH"),
      drop.unused.levels=TRUE)
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x=list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_OGK_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

Figure 15 of \cite{GreenMartin:2014b}.
<<table3-step02r,eval=FALSE>>=
plotdata <- cggRutils:::subset.data.frame(tmpout.t3$result, 
    method %in% c("SEST.BS","SEST.RK"),
      drop.unused.levels=TRUE)
levels(plotdata$method) <- c("BISQUARE S-EST.","ROCKE S-EST")
names(plotdata)[1] <- "DIM"

theplot <- xyplot( mean010.scaled ~ n | DIM,
  data = plotdata,
  groups = method,
  type = "b",
  xlab = "SAMPLE SIZE",
  ylab = "SIMULATED SIZE/0.01",
  main = "",
  as.table = TRUE,
  strip = strip.custom( style = 1, strip.levels=c(TRUE,TRUE) ),
  panel = function(...) {
    panel.superpose(...)
    panel.abline(h = 1, lty="dotted", col="black", lwd=2)
  },
  scale = list(y = list(relation="same"), x=list(rot=45)),
  between = list(x = 0.25, y = 0.5),
  xlim=c(0,1100),
  auto.key = list(x = 0.6, y = 0.25, points = TRUE)
)
trellis.device(pdf, theme=splus.theme, 
  file="Intersection_BISQ_ROCKE_Results_010.pdf")
tss <- trellis.par.get("superpose.symbol")
tss$pch <- c(19,8,15,1:7)
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.symbol",tss)
tss <- trellis.par.get("superpose.line")
tss$col[1:4] <- c("#007EFF","#FF0000","darkgreen","#FF00FF")
trellis.par.set("superpose.line",tss)
print(theplot)
dev.off()
@

\bibliographystyle{plainnat}
\bibliography{HardinRockeExtension}
\end{document}
